
#pragma config(Motor,  motorA,           ,             tmotorEV3_Large, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//
const int BOARD_ROWS = 6;
const int BOARD_COLUMNS = 7;
const int DEFAULT_DISPLAY_LINE = 3;

const int HUMAN_TOKEN_TYPE = 1;
const int ROBOT_TOKEN_TYPE = 2;

 typedef struct
{
  int score, columnOfMove;
} minimaxReturns ;
int horizontalCheck(int *columnHeights,int columnOfMove, int playerToken, int oppoToken);
int verticalCheck(int *columnHeights, int columnOfMove, int playerToken, int oppoToken);
int positiveSlopeCheck(int *columnHeights, int columnOfMove, int playerToken, int oppoToken);
int negativeSlopeCheck(int *columnHeights, int columnOfMove, int playerToken, int oppoToken);



void addTokenToArray(int *columnHeights, int row, int column, int tokenType);
void removeTokenInArray(int *columnHeights, int row, int column);
int robotMove(int *columnHeights);

minimaxReturns* minimaxAlg(int *columnHeights, int depth, bool maxPlayer, int columnOfMove = 0);


int scoreBoard(int *columnHeights, int columnOfMove, int playerToken, int oppoToken);
int scorePoints(int playerToken, int sum); //


void sensorConfig();
void configureMotors();
void waitButton(TEV3Buttons buttonName);
void motorHold(int column);
void playGame(int & currentPlayer);
void dropToken(int *columnHeights, int choiceCol, bool isHumanPlaying); // done
void sortTokens();
int gameWon(int & currentPlayer);
void humanMove(int *columnHeights, int currentCol);
// void HumanMove2(int *columnHeights, int currentCol);
void resetSpinner();

//void gameReset(int currentCol);
int moveSelect(int currentCol);
void spinnerMotor(bool isHumanPlaying); // done
bool legalCheck(int choiceCol);

const int colAngle[7]=
	{0, -70, -145, -215, -300, -400, -528};


int boardArray[BOARD_ROWS][BOARD_COLUMNS] =
    {
		{0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0}
    };

#include "mindsensors-motormux.h"
task main()
{
	int columnHeights[BOARD_COLUMNS] = {0, 0, 0, 0, 0, 0, 0,};


	bool playAgain = true;

	while(playAgain == true)
	{

	MSMMUXinit();
	SensorType[S4] = sensorI2CCustom;
	//bool stillPlaying = false;
	//while(stillPlaying)




	int	currentPlayer = 0;

		sensorConfig();
		configureMotors();

		displayString(DEFAULT_DISPLAY_LINE, "First place cartridges on top");
		displayString(DEFAULT_DISPLAY_LINE + 1, "Then press Enter to play!");
		waitButton(buttonEnter);
		eraseDisplay();

		playGame(currentPlayer);

		eraseDisplay();
		displayString(DEFAULT_DISPLAY_LINE, "Place cartridges at the bottom");
		displayString(DEFAULT_DISPLAY_LINE +1 , "Please press the touch sensor") ;
		displayString(DEFAULT_DISPLAY_LINE + 2,"When ready to sort the tokens");

		while(SensorValue[S1] == 0)
		{}
			eraseDisplay();
			resetSpinner();
			sortTokens();


		displayString(DEFAULT_DISPLAY_LINE, "Please replace cartidges");
		displayString(DEFAULT_DISPLAY_LINE + 1, "press enter once you're done");
		waitButton(buttonEnter);
		eraseDisplay();


		displayString(DEFAULT_DISPLAY_LINE, "Press enter to play again");
		displayString(DEFAULT_DISPLAY_LINE + 1, "Or press up to exit");

			bool choiceSelected = false;
		while(!choiceSelected){
		if(getButtonPress(buttonEnter))
			{
				while(getButtonPress(buttonEnter)){}
				 playAgain = true;
				choiceSelected = true;
				for(int row = 0; row < BOARD_ROWS; row ++)
				{
					for(int col = 0; col < BOARD_COLUMNS; col ++)
					{
					boardArray[row][col] = 0;
					columnHeights[col] = 0;
					}
				}
			}
		else if(getButtonPress(buttonUp))
		{
			while(getButtonPress(buttonUp)){}
			playAgain = false;
			choiceSelected = true;
		}

	}

			eraseDisplay();

	}



		eraseDisplay();
	time1[T2] =0;
	displayString(DEFAULT_DISPLAY_LINE, "Thank you for playing!");
	while(time1[T2] < 7000){}
	eraseDisplay();

}

/*
void gameReset(int currentCol){
	//dropToken(currentConverPos, 1, )
    displayString(DEFAULT_DISPLAY_LINE, "Press enter to continue playing");
	displayString(DEFAULT_DISPLAY_LINE, "press any other to terminate program");
	while(!getButtonPress(buttonAny)){}
	eraseDisplay();
	if(getButtonPress(buttonEnter)){
		//stillPlaying = 1;
		return;
	}

	else{
	//	stillPlaying = 0;
		return;
	}
}
*/

int gameWon(int & currentPlayer)
// assumption: the red = 1 = human, yellow = 2 = robot
{
	int draw = 3, notWon = 0, win = 0;
	if(boardArray[0][0] != 0 && boardArray[0][1] != 0 && boardArray[0][2] != 0 && boardArray[0][3] != 0
		&& boardArray[0][4] != 0 && boardArray[0][5] != 0 && boardArray[0][6] != 0)
	{
		return draw;
	}
	if(currentPlayer == 1)
	{
		win = 1; // human won
	}
	else if(currentPlayer == 2)
	{
		win = 2; // robot won
	}


	for(int row = 5; row >= 0; row--)
	{
		for(int col = 0; col < 7; col++)
		{
				int row1 = row - 1;
				int row2 = row - 2;
				int row3 = row - 3;
			if(row > 2)
			{

					if(boardArray[row][col] == currentPlayer
						&& boardArray[row1][col] == currentPlayer
						&& boardArray[row2][col] == currentPlayer
						&& boardArray[row3][col] == currentPlayer)
					{
						return win;
					} // checks vertical

					if(col < 4)
					{
						if(boardArray[row][col] == currentPlayer
							&& boardArray[row][col + 1] == currentPlayer
							&& boardArray[row][col + 2] == currentPlayer
							&& boardArray[row][col + 3] == currentPlayer)
						{
							return win;
						} // checks horizontal

						if(boardArray[row][col] == currentPlayer
							&& boardArray[row1][col + 1] == currentPlayer
							&& boardArray[row2][col + 2] == currentPlayer
							&& boardArray[row3][col + 3] == currentPlayer)
						{
							return win;
						} // checks +ve slope
					}

			}
			else if(col < 4)
			{
				if(boardArray[row][col] == currentPlayer
					&& boardArray[row][col + 1] == currentPlayer
					&& boardArray[row][col + 2] == currentPlayer
					&& boardArray[row][col + 3] == currentPlayer)
				{
					return win;
				} // checks horizontal

				if(boardArray[row][col] == currentPlayer
					&& boardArray[row + 1][col + 1] == currentPlayer
					&& boardArray[row + 2][col + 2] == currentPlayer
					&& boardArray[row + 3][col + 3] == currentPlayer)
				{
					return win;
				} // checks -ve slope
			}

		}
	}

	return notWon; //not won if neither the robot nor human has a connect 4
}



void playGame(int &currentPlayer){
	currentPlayer = 1;
	int columnHeights[BOARD_COLUMNS] = {0,0,0,0,0,0,0};
	int currentCol = 1;

	while(gameWon(currentPlayer) == 0)
	{
		currentPlayer = 1;
		humanMove(columnHeights, currentCol);
		if(gameWon(currentPlayer) == 0)
		{
			currentPlayer = 2;
		robotMove(columnHeights);
	}
}
	nMotorEncoder[motorA] = 0;
	return;

}

void humanMove(int *columnHeights, int currentCol){
	int choiceCol = 1;
	do {
		choiceCol = moveSelect(choiceCol);
	} while(!legalCheck(choiceCol));

	dropToken(columnHeights, choiceCol, true); // means human is playing
	return;
}


int robotMove(int *columnHeights)
{
    // Use the minimax algorithm to find the best move
    minimaxReturns* values = minimaxAlg(columnHeights, 2, true);

    // Drop the token into the chosen column
    dropToken(columnHeights, values->columnOfMove, false);


    // Return the chosen column
    return values->columnOfMove;
}


/*
void HumanMove2(int *columnHeights, int currentCol){
	int choiceCol = 1;
	do {
		choiceCol = moveSelect(currentCol);
	} while(!legalCheck(choiceCol));

	dropToken(columnHeights, choiceCol, false); // means human is playing

}
*/
int moveSelect(int currentCol)
{
	int selectCol = currentCol;
	eraseDisplay();
	displayString(DEFAULT_DISPLAY_LINE, "Current Column: %d", selectCol);

	while(!getButtonPress(buttonEnter))
	{
		if(getButtonPress(buttonUp))
		{
			while(getButtonPress(buttonUp))
			{}

			if(selectCol == 7)
			{
				selectCol = 1;
			}
			else
			{
				selectCol++;
			}

			eraseDisplay();
			displayString(DEFAULT_DISPLAY_LINE, "Current Column: %d", selectCol);

			wait1Msec(500);
		}
		else if(getButtonPress(buttonDown))
		{
			while(getButtonPress(buttonDown))
			{}

			if(selectCol == 1)
			{
				selectCol = 7;
			}
			else
			{
				selectCol--;
			}

			eraseDisplay();
			displayString(DEFAULT_DISPLAY_LINE, "Current Column: %d", selectCol);

			wait1Msec(500);
		}
	}
	while(getButtonPress(buttonEnter))
	{}

	return selectCol;
}

bool legalCheck(int choiceCol)
{
	if(boardArray[0][choiceCol - 1] == 0 && choiceCol >= 1 && choiceCol <= 7)
  {
    return true;
  }
  return false;
}



void spinnerMotor(bool isHumanPlaying){

	if(isHumanPlaying){
		motor[motorC] = 10;
		while (nMotorEncoder[motorC] < 95)
		{}
		motor[motorC] = 0;
	}

	else{
		motor[motorC] = -10;
		while (nMotorEncoder[motorC] > -5)
		{}
		motor[motorC] = 0;
	}
	return;
}

void configureMotors()
{
	nMotorEncoder[motorA] = nMotorEncoder[motorB] = nMotorEncoder[motorC] = nMotorEncoder[motorD] = 0;

	wait1Msec(50);
	motor[motorA] = motor[motorB] = motor[motorC] = motor[motorD]= 0 ;
	wait1Msec(50);
	MSMMotorEncoderReset(mmotor_S4_1);

}

void sensorConfig() {
	SensorType[S1] = sensorEV3_Touch;
	wait1Msec(50);
	SensorType[S2] = sensorEV3_Color;
	wait1Msec(50);
	SensorMode[S2] = modeEV3Color_Color;
	wait1Msec(50);

}



void dropToken(int *columnHeights, int choiceCol, bool isHumanPlaying)
{
	choiceCol -= 1;

	motor[motorA] = 15;
	motor[motorD] = 15;

	while(nMotorEncoder[motorA] > colAngle[choiceCol])
	{}

	clearTimer(T4);
	bool motorActivated = false;
	while(time1[T4] < 3000)
	{
		motorHold(choiceCol);
		if(time1[T4] > 1000 && !motorActivated)
		{
			spinnerMotor(isHumanPlaying);
			motorActivated = true;
		}

	}
		motor[motorA] = motor[motorD] = 0;
		wait1Msec(500);




	int tokenType = HUMAN_TOKEN_TYPE;
	if(!isHumanPlaying)
	{
		tokenType = ROBOT_TOKEN_TYPE;
	}
	int emptyTokenRow = (BOARD_ROWS - 1) - columnHeights[choiceCol];

  boardArray[emptyTokenRow][choiceCol] = tokenType;
  columnHeights[choiceCol] += 1;

	motor[motorA] = -15;
	motor[motorD] = -15;
	while(nMotorEncoder[motorA] < 0)
	{}
	motor[motorA] = 0;
	motor[motorD] = 0;

	return;

}


void motorHold(int column)
{
		while(nMotorEncoder[motorA] < colAngle[column])
		{
			motor[motorD] = -1;
			motor[motorA] = -2;
		}
		while(nMotorEncoder[motorA] > colAngle[column])
		{
			motor[motorD] = 2;
			motor[motorA] = 1;
		}
		motor[motorD] = 1;
		motor[motorA] = -1;

}

/*
void gameReset(int currentCol){
	//dropToken(currentConverPos, 1, )
    displayString(DEFAULT_DISPLAY_LINE, "Press enter to continue playing");
	displayString(DEFAULT_DISPLAY_LINE, "press any other to terminate program");
	while(!getButtonPress(buttonAny)){}
	eraseDisplay();
	if(getButtonPress(buttonEnter)){
		stillPlaying = 1;
		return;
	}

	else{
		stillPlaying = 0;
		return;
	}
}
*/



void sortTokens(){
	sensorConfig();
	time1[T3] = 0;
	MSMMotor(mmotor_S4_1, -1);
	wait1Msec(100);
	time1[T4] = 0;
	int previousMotor = 100;
	int nextEncoder = 0;

	while(time1[T3] < 7000){
  		if(SensorValue[S2] == 4) {
  			motor[motorB] = -35;
  			while(nMotorEncoder[motorB] > -55){}
  			motor[motorB] = 0;
  			time1[T3] = 0;
		}

		else if(SensorValue[S2] == 5) {
	 		wait1Msec(500);
	    	motor[motorB] = 35;
  			while(nMotorEncoder[motorB] < 0){}
  			motor[motorB] = 0;
  			time1[T3] = 0;

		}

		if(time1[T4] >= 1000){

				if(previousMotor == MSMMotorEncoder(mmotor_S4_1)){
						MSMMotor(mmotor_S4_1, 1);
						wait1Msec(1000);
						MSMMotor(mmotor_S4_1, -1);
						}

						previousMotor = MSMMotorEncoder(mmotor_S4_1);
						time1[T4] = 0;
					}
    }

	motor[motorB] = 50;
  	while(nMotorEncoder[motorB] < -10)
  		{}
  	MSMotorStop(mmotor_S4_1);
  	motor[motorB] = 0;
}

void waitButton(TEV3Buttons buttonName)
{
	while(!getButtonPress(buttonName))
	{}
	while(getButtonPress(buttonName))
	{}

	return;
}







void resetSpinner()
{
	motor[motorC] = 20;
	while(nMotorEncoder[motorC] < 360)
{}
	motor[motorC] = 0;

}



int scorePoints(int playerToken, int sum)
{
  if(playerToken == ROBOT_TOKEN_TYPE) //2, 5, 777, -2, -10, -999
  {
    if(sum == 2)
    {
      return 2;
    }
    else if(sum == 3)
    {
      return 10;
    }
    else if(sum == 4)
    {
      return 777;
    }
  }
  else if(playerToken == HUMAN_TOKEN_TYPE)
  {
    if(sum == 2)
    {
      return -2;
    }
    else if(sum == 3)
    {
      return -5;
    }
    else if(sum == 4)
    {
      return -999;
    }
  }

  return 0;
}

int horizontalCheck( int *columnHeights, int columnOfMove, int playerToken, int oppoToken)
{
  int score = 0;

  const int TOKEN_ROW = BOARD_ROWS - columnHeights[columnOfMove];
  const int TOKEN_COLUMN = columnOfMove;

  int startRow[2] = {-1, -2}; //can maybe intialize with token row for horizontal...
  int startCol[2] = {-3, -4};
  int endRow[2] = {-5, -6};
  int endCol[2] = {-7, -8};

  bool hitBarrier = false;
  int sum = 1;
  int spacesLeft = 3;

  for(int colOffset = 1; colOffset <= spacesLeft && !hitBarrier; colOffset++)
  {
    int currentToken = boardArray[TOKEN_ROW][TOKEN_COLUMN + colOffset];

    if(currentToken == oppoToken || TOKEN_COLUMN + colOffset == BOARD_COLUMNS)
    {
      hitBarrier = true;
      startRow[0] = TOKEN_ROW;
      startCol[0] = TOKEN_COLUMN + colOffset - 1;
      spacesLeft -= (colOffset - 1);
    }
    else if(currentToken == playerToken)
    {
      sum++;
    }
  }

  if(hitBarrier)
  {
    hitBarrier = false;

    for(int colOffset = 1; colOffset <= spacesLeft && !hitBarrier; colOffset++)
    {
      int currentToken = boardArray[TOKEN_ROW][TOKEN_COLUMN - colOffset];

      if(currentToken == oppoToken || TOKEN_COLUMN - colOffset == -1)
      {
        hitBarrier = true;
        startRow[0] = -1;
        startCol[0] = -3;
      }
      else if(currentToken == playerToken)
      {
        sum++;
      }
    }

    if(!hitBarrier)
    {
      endRow[0] = TOKEN_ROW;
      endCol[0] = TOKEN_COLUMN - spacesLeft;
    }
  }
  else
  {
    startRow[0] = TOKEN_ROW;
    startCol[0] = TOKEN_COLUMN;
    endRow[0] = TOKEN_ROW;
    endCol[0] = TOKEN_COLUMN + spacesLeft;
  }

  if(!hitBarrier)
  {
    score += scorePoints(playerToken, sum);
  }

  hitBarrier = false;
  sum = 1;
  spacesLeft = 3;

  for(int colOffset = 1; colOffset <= spacesLeft && !hitBarrier; colOffset++)
  {
    int currentToken = boardArray[TOKEN_ROW][TOKEN_COLUMN - colOffset];

    if(currentToken == oppoToken || TOKEN_COLUMN - colOffset == -1)
    {
      hitBarrier = true;
      startRow[1] = TOKEN_ROW;
      startCol[1] = TOKEN_COLUMN - colOffset + 1;
      spacesLeft -= (colOffset - 1);
    }
    else if(currentToken == playerToken)
    {
      sum++;
    }
  }

  if(hitBarrier)
  {
    hitBarrier = false;

    for(int colOffset = 1; colOffset <= spacesLeft && !hitBarrier; colOffset++)
    {
      int currentToken = boardArray[TOKEN_ROW][TOKEN_COLUMN + colOffset];

      if(currentToken == oppoToken || TOKEN_COLUMN + colOffset == BOARD_COLUMNS)
      {
        hitBarrier = true;
        startRow[1] = -2;
        startCol[1] = -4;
      }
      else if(currentToken == playerToken)
      {
        sum++;
      }
    }

    if(!hitBarrier)
    {
      endRow[1] = TOKEN_ROW;
      endCol[1] = TOKEN_COLUMN + spacesLeft;
    }
  }
  else
  {
    startRow[1] = TOKEN_ROW;
    startCol[1] = TOKEN_COLUMN;
    endRow[1] = TOKEN_ROW;
    endCol[1] = TOKEN_COLUMN - spacesLeft;
  }

  if(!hitBarrier && !(startCol[0] == endCol[1] && startCol[1] == endCol[0] || startCol[0] == startCol[1] && endCol[0] == endCol[1]))
  {
    score += scorePoints(playerToken, sum);
  }

  return score;

}

int verticalCheck(int *columnHeights, int columnOfMove, int playerToken, int oppoToken)
{
  int score = 0;

  const int TOKEN_ROW = BOARD_ROWS - columnHeights[columnOfMove];
  const int TOKEN_COLUMN = columnOfMove;

  int startRow[2] = {-1, -2};
  int startCol[2] = {-3, -4}; //can maybe intialize with token column for vertical...
  int endRow[2] = {-5, -6};
  int endCol[2] = {-7, -8};

  bool hitBarrier = false;
  int sum = 1;
  int spacesLeft = 3;

  for(int rowOffset = 1; rowOffset <= spacesLeft && !hitBarrier; rowOffset++)
  {
    int currentToken = boardArray[TOKEN_ROW - rowOffset][TOKEN_COLUMN];

    if(currentToken == oppoToken || TOKEN_ROW - rowOffset == -1)
    {
      hitBarrier = true;
      startRow[0] = TOKEN_ROW - rowOffset + 1;
      startCol[0] = TOKEN_COLUMN;
      spacesLeft -= (rowOffset - 1);
    }
    else if(currentToken == playerToken)
    {
      sum++;
    }
  }

  if(hitBarrier)
  {
    hitBarrier = false;

    for(int rowOffset = 1; rowOffset <= spacesLeft && !hitBarrier; rowOffset++)
    {
      int currentToken = boardArray[TOKEN_ROW + rowOffset][TOKEN_COLUMN];

      if(currentToken == oppoToken || TOKEN_ROW + rowOffset == BOARD_ROWS)
      {
        hitBarrier = true;
        startRow[0] = -1;
        startCol[0] = -3;
      }
      else if(currentToken == playerToken)
      {
        sum++;
      }
    }

    if(!hitBarrier)
    {
      endRow[0] = TOKEN_ROW + spacesLeft;
      endCol[0] = TOKEN_COLUMN;
    }
  }
  else
  {
    startRow[0] = TOKEN_ROW;
    startCol[0] = TOKEN_COLUMN;
    endRow[0] = TOKEN_ROW - spacesLeft;
    endCol[0] = TOKEN_COLUMN;
  }

  if(!hitBarrier)
  {
    score += scorePoints(playerToken, sum);
  }

  hitBarrier = false;
  sum = 1;
  spacesLeft = 3;

  for(int rowOffset = 1; rowOffset <= spacesLeft && !hitBarrier; rowOffset++)
  {
    int currentToken = boardArray[TOKEN_ROW + rowOffset][TOKEN_COLUMN];

    if(currentToken == oppoToken || TOKEN_ROW + rowOffset == BOARD_ROWS)
    {
      hitBarrier = true;
      startRow[1] = TOKEN_ROW + rowOffset - 1;
      startCol[1] = TOKEN_COLUMN;
      spacesLeft -= (rowOffset - 1);
    }
    else if(currentToken == playerToken)
    {
      sum++;
    }
  }

  if(hitBarrier)
  {
    hitBarrier = false;

    for(int rowOffset = 1; rowOffset <= spacesLeft && !hitBarrier; rowOffset++)
    {
      int currentToken = boardArray[TOKEN_ROW - rowOffset][TOKEN_COLUMN];

      if(currentToken == oppoToken || TOKEN_ROW - rowOffset == -1)
      {
        hitBarrier = true;
        startRow[1] = -2;
        startCol[1] = -4;
      }
      else if(currentToken == playerToken)
      {
        sum++;
      }
    }

    if(!hitBarrier)
    {
      endRow[1] = TOKEN_ROW - spacesLeft;
      endCol[1] = TOKEN_COLUMN;
    }
  }
  else
  {
    startRow[1] = TOKEN_ROW;
    startCol[1] = TOKEN_COLUMN;
    endRow[1] = TOKEN_ROW + spacesLeft;
    endCol[1] = TOKEN_COLUMN;
  }

  if(!hitBarrier && !(startRow[0] == endRow[1] && startRow[1] == endRow[0] || startRow[0] == startRow[1] && endRow[0] == endRow[1]))
  {
    score += scorePoints(playerToken, sum);
  }

  return score;

}

int positiveSlopeCheck(int *columnHeights, int columnOfMove, int playerToken, int oppoToken)
{
  int score = 0;

  const int TOKEN_ROW = BOARD_ROWS - columnHeights[columnOfMove];
  const int TOKEN_COLUMN = columnOfMove;

  int startRow[2] = {-1, -2};
  int startCol[2] = {-3, -4};
  int endRow[2] = {-5, -6};
  int endCol[2] = {-7, -8};

  bool hitBarrier = false;
  int sum = 1;
  int spacesLeft = 3;

  for(int slopeOffset = 1; slopeOffset <= spacesLeft && !hitBarrier; slopeOffset++)
  {
    int currentToken = boardArray[TOKEN_ROW - slopeOffset][TOKEN_COLUMN + slopeOffset];

    if(currentToken == oppoToken || TOKEN_ROW - slopeOffset == -1 || TOKEN_COLUMN + slopeOffset == BOARD_COLUMNS)
    {
      hitBarrier = true;
      startRow[0] = TOKEN_ROW - slopeOffset + 1;
      startCol[0] = TOKEN_COLUMN + slopeOffset - 1;
      spacesLeft -= (slopeOffset - 1);
    }
    else if(currentToken == playerToken)
    {
      sum++;
    }
  }

  if(hitBarrier)
  {
    hitBarrier = false;

    for(int slopeOffset = 1; slopeOffset <= spacesLeft && !hitBarrier; slopeOffset++)
    {
      int currentToken = boardArray[TOKEN_ROW + slopeOffset][TOKEN_COLUMN - slopeOffset];

      if(currentToken == oppoToken || TOKEN_ROW + slopeOffset == BOARD_ROWS || TOKEN_COLUMN - slopeOffset == -1)
      {
        hitBarrier = true;
        startRow[0] = -1;
        startCol[0] = -3;
      }
      else if(currentToken == playerToken)
      {
        sum++;
      }
    }

    if(!hitBarrier)
    {
      endRow[0] = TOKEN_ROW + spacesLeft;
      endCol[0] = TOKEN_COLUMN - spacesLeft;
    }
  }
  else
  {
    startRow[0] = TOKEN_ROW;
    startCol[0] = TOKEN_COLUMN;
    endRow[0] = TOKEN_ROW - spacesLeft;
    endCol[0] = TOKEN_COLUMN + spacesLeft;
  }

  if(!hitBarrier)
  {
    score += scorePoints(playerToken, sum);
  }

  hitBarrier = false;
  sum = 1;
  spacesLeft = 3;

  for(int slopeOffset = 1; slopeOffset <= spacesLeft && !hitBarrier; slopeOffset++)
  {
    int currentToken = boardArray[TOKEN_ROW + slopeOffset][TOKEN_COLUMN - slopeOffset];

    if(currentToken == oppoToken || TOKEN_ROW + slopeOffset == BOARD_ROWS || TOKEN_COLUMN - slopeOffset == -1)
    {
      hitBarrier = true;
      startRow[1] = TOKEN_ROW + slopeOffset - 1;
      startCol[1] = TOKEN_COLUMN - slopeOffset + 1;
      spacesLeft -= (slopeOffset - 1);
    }
    else if(currentToken == playerToken)
    {
      sum++;
    }
  }

  if(hitBarrier)
  {
    hitBarrier = false;

    for(int slopeOffset = 1; slopeOffset <= spacesLeft && !hitBarrier; slopeOffset++)
    {
      int currentToken = boardArray[TOKEN_ROW - slopeOffset][TOKEN_COLUMN + slopeOffset];

      if(currentToken == oppoToken || TOKEN_ROW - slopeOffset == -1 || TOKEN_COLUMN + slopeOffset == BOARD_COLUMNS)
      {
        hitBarrier = true;
        startRow[1] = -2;
        startCol[1] = -4;
      }
      else if(currentToken == playerToken)
      {
        sum++;
      }
    }

    if(!hitBarrier)
    {
      endRow[1] = TOKEN_ROW - spacesLeft;
      endCol[1] = TOKEN_COLUMN + spacesLeft;
    }
  }
  else
  {
    startRow[1] = TOKEN_ROW;
    startCol[1] = TOKEN_COLUMN;
    endRow[1] = TOKEN_ROW + spacesLeft;
    endCol[1] = TOKEN_COLUMN - spacesLeft;
  }

  if(!hitBarrier && !((startRow[0] == endRow[1] && startCol[0] == endCol[1] && endRow[0] == startRow[1] && endCol[0] == startCol[1]) || (startRow[0] == startRow[1] && startCol[0] == startCol[1] && endRow[0] == endRow[1] && endCol[0] == endCol[1])))
  {
    score += scorePoints(playerToken, sum);
  }

  return score;

}

int negativeSlopeCheck(int *columnHeights, int columnOfMove, int playerToken, int oppoToken)
{
  int score = 0;

  const int TOKEN_ROW = BOARD_ROWS - columnHeights[columnOfMove];
  const int TOKEN_COLUMN = columnOfMove;

  int startRow[2] = {-1, -2};
  int startCol[2] = {-3, -4};
  int endRow[2] = {-5, -6};
  int endCol[2] = {-7, -8};

  bool hitBarrier = false;
  int sum = 1;
  int spacesLeft = 3;

  for(int slopeOffset = 1; slopeOffset <= spacesLeft && !hitBarrier; slopeOffset++)
  {
    int currentToken = boardArray[TOKEN_ROW - slopeOffset][TOKEN_COLUMN - slopeOffset];

    if(currentToken == oppoToken || TOKEN_ROW - slopeOffset == -1 || TOKEN_COLUMN - slopeOffset == -1)
    {
      hitBarrier = true;
      startRow[0] = TOKEN_ROW - slopeOffset + 1;
      startCol[0] = TOKEN_COLUMN - slopeOffset + 1;
      spacesLeft -= (slopeOffset - 1);
    }
    else if(currentToken == playerToken)
    {
      sum++;
    }
  }

  if(hitBarrier)
  {
    hitBarrier = false;

    for(int slopeOffset = 1; slopeOffset <= spacesLeft && !hitBarrier; slopeOffset++)
    {
      int currentToken = boardArray[TOKEN_ROW + slopeOffset][TOKEN_COLUMN + slopeOffset];

      if(currentToken == oppoToken || TOKEN_ROW + slopeOffset == BOARD_ROWS || TOKEN_COLUMN + slopeOffset == BOARD_COLUMNS)
      {
        hitBarrier = true;
        startRow[0] = -1;
        startCol[0] = -3;
      }
      else if(currentToken == playerToken)
      {
        sum++;
      }
    }

    if(!hitBarrier)
    {
      endRow[0] = TOKEN_ROW + spacesLeft;
      endCol[0] = TOKEN_COLUMN + spacesLeft;
    }
  }
  else
  {
    startRow[0] = TOKEN_ROW;
    startCol[0] = TOKEN_COLUMN;
    endRow[0] = TOKEN_ROW - spacesLeft;
    endCol[0] = TOKEN_COLUMN - spacesLeft;
  }

  if(!hitBarrier)
  {
    score += scorePoints(playerToken, sum);
  }

  hitBarrier = false;
  sum = 1;
  spacesLeft = 3;

  for(int slopeOffset = 1; slopeOffset <= spacesLeft && !hitBarrier; slopeOffset++)
  {
    int currentToken = boardArray[TOKEN_ROW + slopeOffset][TOKEN_COLUMN + slopeOffset];

    if(currentToken == oppoToken || TOKEN_ROW + slopeOffset == BOARD_ROWS || TOKEN_COLUMN + slopeOffset == BOARD_COLUMNS)
    {
      hitBarrier = true;
      startRow[1] = TOKEN_ROW + slopeOffset - 1;
      startCol[1] = TOKEN_COLUMN + slopeOffset - 1;
      spacesLeft -= (slopeOffset - 1);
    }
    else if(currentToken == playerToken)
    {
      sum++;
    }
  }

  if(hitBarrier)
  {
    hitBarrier = false;

    for(int slopeOffset = 1; slopeOffset <= spacesLeft && !hitBarrier; slopeOffset++)
    {
      int currentToken = boardArray[TOKEN_ROW - slopeOffset][TOKEN_COLUMN - slopeOffset];

      if(currentToken == oppoToken || TOKEN_ROW - slopeOffset == -1 || TOKEN_COLUMN - slopeOffset == -1)
      {
        hitBarrier = true;
        startRow[1] = -2;
        startCol[1] = -4;
      }
      else if(currentToken == playerToken)
      {
        sum++;
      }
    }

    if(!hitBarrier)
    {
      endRow[1] = TOKEN_ROW - spacesLeft;
      endCol[1] = TOKEN_COLUMN - spacesLeft;
    }
  }
  else
  {
    startRow[1] = TOKEN_ROW;
    startCol[1] = TOKEN_COLUMN;
    endRow[1] = TOKEN_ROW + spacesLeft;
    endCol[1] = TOKEN_COLUMN + spacesLeft;
  }

  if(!hitBarrier && !((startRow[0] == endRow[1] && startCol[0] == endCol[1] && endRow[0] == startRow[1] && endCol[0] == startCol[1]) || (startRow[0] == startRow[1] && startCol[0] == startCol[1] && endRow[0] == endRow[1] && endCol[0] == endCol[1])))
  {
    score += scorePoints(playerToken, sum);
  }

  return score;

}

int scoreBoard(int *columnHeights, int columnOfMove, int playerToken, int oppoToken)
{
  int score = 0;

  for(int colDropIndex = 0; colDropIndex < BOARD_COLUMNS; colDropIndex++)
  {
    const int emptyTokenRow = (BOARD_ROWS - 1) - columnHeights[colDropIndex];
    if(emptyTokenRow > -1 && boardArray[emptyTokenRow][colDropIndex] == 0)
    {
      addTokenToArray(columnHeights, emptyTokenRow, colDropIndex, oppoToken);

      /*cout << "(" << emptyTokenRow << ", " << colDropIndex << "): "
           << horizontalCheck(boardArray, columnHeights, colDropIndex, oppoToken, playerToken) << ", "
           << verticalCheck(boardArray, columnHeights, colDropIndex, oppoToken, playerToken) << ", "
           << positiveSlopeCheck(boardArray, columnHeights, colDropIndex, oppoToken, playerToken) << ", "
           << negativeSlopeCheck(boardArray, columnHeights, colDropIndex, oppoToken, playerToken) << endl;*/

      if(colDropIndex == columnOfMove)
      {
        score += horizontalCheck(columnHeights, columnOfMove, oppoToken, playerToken);
        score += positiveSlopeCheck(columnHeights, columnOfMove, oppoToken, playerToken);
        score += negativeSlopeCheck(columnHeights, columnOfMove, oppoToken, playerToken);
      }
      else if(horizontalCheck(columnHeights, colDropIndex, oppoToken, playerToken) <= -100 || verticalCheck( columnHeights, colDropIndex, oppoToken, playerToken) <= -100 || positiveSlopeCheck( columnHeights, colDropIndex, oppoToken, playerToken) <= -100 || negativeSlopeCheck(columnHeights, colDropIndex, oppoToken, playerToken) <= -100)
      {
        //displayScore(boardArray, colDropIndex, -100);
        removeTokenInArray( columnHeights, emptyTokenRow, colDropIndex);
        return -100;
      }

      removeTokenInArray( columnHeights, emptyTokenRow, colDropIndex);
    }
  }

  if(columnOfMove == 3)
  {
    if(playerToken == ROBOT_TOKEN_TYPE)
    {
      score += 4;
    }
    else
    {
      score -= 2;
    }
  }

  score += horizontalCheck( columnHeights, columnOfMove, playerToken, oppoToken);
  score += verticalCheck( columnHeights, columnOfMove, playerToken, oppoToken);
  score += positiveSlopeCheck( columnHeights, columnOfMove, playerToken, oppoToken);
  score += negativeSlopeCheck( columnHeights, columnOfMove, playerToken, oppoToken);

  //displayScore(boardArray, columnOfMove, score);

  return score;



}


//Robot Player Functions


minimaxReturns* minimaxAlg(int *columnHeights, int depth, bool maxPlayer, int columnOfMove)
{

  if(depth == 0) //add gamestate
  {
    minimaxReturns scoreValue;
    if(maxPlayer)
    {
      scoreValue.score = scoreBoard(columnHeights, columnOfMove, HUMAN_TOKEN_TYPE, ROBOT_TOKEN_TYPE);
    }
    else
    {
      scoreValue.score = scoreBoard(columnHeights, columnOfMove, ROBOT_TOKEN_TYPE, HUMAN_TOKEN_TYPE);
    }

    return scoreValue;
  }

  if(maxPlayer)
  {
    minimaxReturns maxValues;
    maxValues.score = -9999;
    maxValues.columnOfMove = 1;

    for(int colDropIndex = 0; colDropIndex < BOARD_COLUMNS; colDropIndex++) //Drops a token in each column to score that potential move
    {
      const int emptyTokenRow = (BOARD_ROWS - 1) - columnHeights[colDropIndex]; //Checks if a column is not full

      if(emptyTokenRow > -1)
      {
        addTokenToArray(columnHeights, emptyTokenRow, colDropIndex, ROBOT_TOKEN_TYPE);

        minimaxReturns* possibleMoveScore = minimaxAlg(columnHeights, depth - 1, false, colDropIndex);

      if (possibleMoveScore->score > maxValues.score /* && possibleMoveScore->score != maxValues->score */)
{
    maxValues.score = possibleMoveScore->score;
    maxValues.columnOfMove = colDropIndex + 1;
}


        removeTokenInArray( columnHeights, emptyTokenRow, colDropIndex);
     }

    }


    return maxValues;

  }
  else
  {
    minimaxReturns minValues;
    minValues.score = 9999;
    minValues.columnOfMove = 1;

    for(int colDropIndex = 0; colDropIndex < BOARD_COLUMNS; colDropIndex++) //Drops a token in each column to score that potential move
    {
      const int emptyTokenRow = (BOARD_ROWS - 1) - columnHeights[colDropIndex]; //Checks if a column is not full

      if(emptyTokenRow > -1)
      {
        addTokenToArray( columnHeights, emptyTokenRow, colDropIndex, HUMAN_TOKEN_TYPE); //dont forget to do this in terms of min for human !!

        minimaxReturns* possibleMoveScore = minimaxAlg( columnHeights, depth - 1, true, colDropIndex);

        if (possibleMoveScore->score < minValues.score /* && possibleMoveScore->score != minValues->score */)
				{
    			minValues.score = possibleMoveScore->score;
  		 		 minValues.columnOfMove = colDropIndex + 1;
				}

        removeTokenInArray(columnHeights, emptyTokenRow, colDropIndex);
     }

    }


    return minValues;

  }

}

void addTokenToArray(int *columnHeights, int row, int column, int tokenType)
{
  boardArray[row][column] = tokenType;
  columnHeights[column] += 1;

  return;
}

void removeTokenInArray( int *columnHeights, int row, int column)
{
  boardArray[row][column] = 0;
  columnHeights[column] -= 1;

  return;
}
